{
  "address": "0x0A56888270F7E3693907e78d845aa58F85C711C1",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract ComptrollerLensInterface",
          "name": "comptroller",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "rewardsAccrued",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "rewardTokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "accrued",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xb6cd65ccdd9d185ba54fdb982cd2942be9b253b5a70cf4adfe1ebbf08f60c3f2",
  "receipt": {
    "to": null,
    "from": "0x6a39C1B89a25a8fA399fF73766417ED2213d5dEe",
    "contractAddress": "0x0A56888270F7E3693907e78d845aa58F85C711C1",
    "transactionIndex": 0,
    "gasUsed": "388577",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xbc74f9e4c82661f66441f20cd8ed5ae0ba035ba70fb8ec7c34fcaf977f326242",
    "transactionHash": "0xb6cd65ccdd9d185ba54fdb982cd2942be9b253b5a70cf4adfe1ebbf08f60c3f2",
    "logs": [],
    "blockNumber": 1295973,
    "cumulativeGasUsed": "388577",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "24d35fea140db672f962df919b678bdd",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract ComptrollerLensInterface\",\"name\":\"comptroller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"rewardsAccrued\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"accrued\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Lens/BasicLens.sol\":\"BasicLens\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x247c62047745915c0af6b955470a72d1696ebad4352d7d3011aef1a2463cd888\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x037c334add4b033ad3493038c25be1682d78c00992e1acb0e2795caff3925271\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2edcb41c121abc510932e8d83ff8b82cf9cdde35e7c297622f5c29ef0af25183\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"contracts/CToken.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\nimport \\\"./ComptrollerInterface.sol\\\";\\r\\nimport \\\"./CTokenInterfaces.sol\\\";\\r\\nimport \\\"./ErrorReporter.sol\\\";\\r\\nimport \\\"./EIP20Interface.sol\\\";\\r\\nimport \\\"./InterestRateModel.sol\\\";\\r\\nimport \\\"./ExponentialNoError.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Compound's CToken Contract\\r\\n * @notice Abstract base for CTokens\\r\\n * @author Compound\\r\\n */\\r\\nabstract contract CToken is\\r\\n    CTokenInterface,\\r\\n    ExponentialNoError,\\r\\n    TokenErrorReporter\\r\\n{\\r\\n    /**\\r\\n     * @notice Initialize the money market\\r\\n     * @param comptroller_ The address of the Comptroller\\r\\n     * @param interestRateModel_ The address of the interest rate model\\r\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\r\\n     * @param name_ EIP-20 name of this token\\r\\n     * @param symbol_ EIP-20 symbol of this token\\r\\n     * @param decimals_ EIP-20 decimal precision of this token\\r\\n     */\\r\\n    function initialize(\\r\\n        ComptrollerInterface comptroller_,\\r\\n        InterestRateModel interestRateModel_,\\r\\n        uint256 initialExchangeRateMantissa_,\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_\\r\\n    ) public {\\r\\n        require(msg.sender == admin, \\\"only admin may initialize the market\\\");\\r\\n        require(\\r\\n            accrualBlockNumber == 0 && borrowIndex == 0,\\r\\n            \\\"market may only be initialized once\\\"\\r\\n        );\\r\\n\\r\\n        // Set initial exchange rate\\r\\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\\r\\n        require(\\r\\n            initialExchangeRateMantissa > 0,\\r\\n            \\\"initial exchange rate must be greater than zero.\\\"\\r\\n        );\\r\\n\\r\\n        // Set the comptroller\\r\\n        uint256 err = _setComptroller(comptroller_);\\r\\n        require(err == NO_ERROR, \\\"setting comptroller failed\\\");\\r\\n\\r\\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\\r\\n        accrualBlockNumber = getBlockNumber();\\r\\n        borrowIndex = mantissaOne;\\r\\n\\r\\n        // Set the interest rate model (depends on block number / borrow index)\\r\\n        err = _setInterestRateModelFresh(interestRateModel_);\\r\\n        require(err == NO_ERROR, \\\"setting interest rate model failed\\\");\\r\\n\\r\\n        name = name_;\\r\\n        symbol = symbol_;\\r\\n        decimals = decimals_;\\r\\n\\r\\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\\r\\n     * @dev Called by both `transfer` and `transferFrom` internally\\r\\n     * @param spender The address of the account performing the transfer\\r\\n     * @param src The address of the source account\\r\\n     * @param dst The address of the destination account\\r\\n     * @param tokens The number of tokens to transfer\\r\\n     * @return 0 if the transfer succeeded, else revert\\r\\n     */\\r\\n    function transferTokens(\\r\\n        address spender,\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint256 tokens\\r\\n    ) internal returns (uint256) {\\r\\n        /* Fail if transfer not allowed */\\r\\n        uint256 allowed = comptroller.transferAllowed(\\r\\n            address(this),\\r\\n            src,\\r\\n            dst,\\r\\n            tokens\\r\\n        );\\r\\n        if (allowed != 0) {\\r\\n            revert TransferComptrollerRejection(allowed);\\r\\n        }\\r\\n\\r\\n        /* Do not allow self-transfers */\\r\\n        if (src == dst) {\\r\\n            revert TransferNotAllowed();\\r\\n        }\\r\\n\\r\\n        /* Get the allowance, infinite for the account owner */\\r\\n        uint256 startingAllowance = 0;\\r\\n        if (spender == src) {\\r\\n            startingAllowance = type(uint256).max;\\r\\n        } else {\\r\\n            startingAllowance = transferAllowances[src][spender];\\r\\n        }\\r\\n\\r\\n        /* Do the calculations, checking for {under,over}flow */\\r\\n        uint256 allowanceNew = startingAllowance - tokens;\\r\\n        uint256 srcTokensNew = accountTokens[src] - tokens;\\r\\n        uint256 dstTokensNew = accountTokens[dst] + tokens;\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        accountTokens[src] = srcTokensNew;\\r\\n        accountTokens[dst] = dstTokensNew;\\r\\n\\r\\n        /* Eat some of the allowance (if necessary) */\\r\\n        if (startingAllowance != type(uint256).max) {\\r\\n            transferAllowances[src][spender] = allowanceNew;\\r\\n        }\\r\\n\\r\\n        /* We emit a Transfer event */\\r\\n        emit Transfer(src, dst, tokens);\\r\\n\\r\\n        // unused function\\r\\n        // comptroller.transferVerify(address(this), src, dst, tokens);\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\r\\n     * @param dst The address of the destination account\\r\\n     * @param amount The number of tokens to transfer\\r\\n     * @return Whether or not the transfer succeeded\\r\\n     */\\r\\n    function transfer(\\r\\n        address dst,\\r\\n        uint256 amount\\r\\n    ) external override nonReentrant returns (bool) {\\r\\n        return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\r\\n     * @param src The address of the source account\\r\\n     * @param dst The address of the destination account\\r\\n     * @param amount The number of tokens to transfer\\r\\n     * @return Whether or not the transfer succeeded\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint256 amount\\r\\n    ) external override nonReentrant returns (bool) {\\r\\n        return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n     * @dev This will overwrite the approval amount for `spender`\\r\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\\r\\n     * @return Whether or not the approval succeeded\\r\\n     */\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        address src = msg.sender;\\r\\n        transferAllowances[src][spender] = amount;\\r\\n        emit Approval(src, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the current allowance from `owner` for `spender`\\r\\n     * @param owner The address of the account which owns the tokens to be spent\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @return The number of tokens allowed to be spent (-1 means infinite)\\r\\n     */\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view override returns (uint256) {\\r\\n        return transferAllowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the token balance of the `owner`\\r\\n     * @param owner The address of the account to query\\r\\n     * @return The number of tokens owned by `owner`\\r\\n     */\\r\\n    function balanceOf(address owner) external view override returns (uint256) {\\r\\n        return accountTokens[owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the underlying balance of the `owner`\\r\\n     * @dev This also accrues interest in a transaction\\r\\n     * @param owner The address of the account to query\\r\\n     * @return The amount of underlying owned by `owner`\\r\\n     */\\r\\n    function balanceOfUnderlying(\\r\\n        address owner\\r\\n    ) external override returns (uint256) {\\r\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\\r\\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\\r\\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\\r\\n     * @param account Address of the account to snapshot\\r\\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\\r\\n     */\\r\\n    function getAccountSnapshot(\\r\\n        address account\\r\\n    ) external view override returns (uint256, uint256, uint256, uint256) {\\r\\n        return (\\r\\n            NO_ERROR,\\r\\n            accountTokens[account],\\r\\n            borrowBalanceStoredInternal(account),\\r\\n            exchangeRateStoredInternal()\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to simply retrieve block number\\r\\n     *  This exists mainly for inheriting test contracts to stub this result.\\r\\n     */\\r\\n    function getBlockNumber() internal view virtual returns (uint256) {\\r\\n        return block.timestamp;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current per-block borrow interest rate for this cToken\\r\\n     * @return The borrow interest rate per block, scaled by 1e18\\r\\n     */\\r\\n    function borrowRatePerBlock() external view override returns (uint256) {\\r\\n        return\\r\\n            interestRateModel.getBorrowRate(\\r\\n                getCashPrior(),\\r\\n                totalBorrows,\\r\\n                totalReserves\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current per-block supply interest rate for this cToken\\r\\n     * @return The supply interest rate per block, scaled by 1e18\\r\\n     */\\r\\n    function supplyRatePerBlock() external view override returns (uint256) {\\r\\n        return\\r\\n            interestRateModel.getSupplyRate(\\r\\n                getCashPrior(),\\r\\n                totalBorrows,\\r\\n                totalReserves,\\r\\n                reserveFactorMantissa\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current total borrows plus accrued interest\\r\\n     * @return The total borrows with interest\\r\\n     */\\r\\n    function totalBorrowsCurrent()\\r\\n        external\\r\\n        override\\r\\n        nonReentrant\\r\\n        returns (uint256)\\r\\n    {\\r\\n        accrueInterest();\\r\\n        return totalBorrows;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\r\\n     * @param account The address whose balance should be calculated after updating borrowIndex\\r\\n     * @return The calculated balance\\r\\n     */\\r\\n    function borrowBalanceCurrent(\\r\\n        address account\\r\\n    ) external override nonReentrant returns (uint256) {\\r\\n        accrueInterest();\\r\\n        return borrowBalanceStored(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return the borrow balance of account based on stored data\\r\\n     * @param account The address whose balance should be calculated\\r\\n     * @return The calculated balance\\r\\n     */\\r\\n    function borrowBalanceStored(\\r\\n        address account\\r\\n    ) public view override returns (uint256) {\\r\\n        return borrowBalanceStoredInternal(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return the borrow balance of account based on stored data\\r\\n     * @param account The address whose balance should be calculated\\r\\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\\r\\n     */\\r\\n    function borrowBalanceStoredInternal(\\r\\n        address account\\r\\n    ) internal view returns (uint256) {\\r\\n        /* Get borrowBalance and borrowIndex */\\r\\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\\r\\n\\r\\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\\r\\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\\r\\n         */\\r\\n        if (borrowSnapshot.principal == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        /* Calculate new borrow balance using the interest index:\\r\\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\\r\\n         */\\r\\n        uint256 principalTimesIndex = borrowSnapshot.principal * borrowIndex;\\r\\n        return principalTimesIndex / borrowSnapshot.interestIndex;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrue interest then return the up-to-date exchange rate\\r\\n     * @return Calculated exchange rate scaled by 1e18\\r\\n     */\\r\\n    function exchangeRateCurrent()\\r\\n        public\\r\\n        override\\r\\n        nonReentrant\\r\\n        returns (uint256)\\r\\n    {\\r\\n        accrueInterest();\\r\\n        return exchangeRateStored();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the exchange rate from the underlying to the CToken\\r\\n     * @dev This function does not accrue interest before calculating the exchange rate\\r\\n     * @return Calculated exchange rate scaled by 1e18\\r\\n     */\\r\\n    function exchangeRateStored() public view override returns (uint256) {\\r\\n        return exchangeRateStoredInternal();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the exchange rate from the underlying to the CToken\\r\\n     * @dev This function does not accrue interest before calculating the exchange rate\\r\\n     * @return calculated exchange rate scaled by 1e18\\r\\n     */\\r\\n    function exchangeRateStoredInternal()\\r\\n        internal\\r\\n        view\\r\\n        virtual\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 _totalSupply = totalSupply;\\r\\n        if (_totalSupply == 0) {\\r\\n            /*\\r\\n             * If there are no tokens minted:\\r\\n             *  exchangeRate = initialExchangeRate\\r\\n             */\\r\\n            return initialExchangeRateMantissa;\\r\\n        } else {\\r\\n            /*\\r\\n             * Otherwise:\\r\\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\\r\\n             */\\r\\n            uint256 totalCash = getCashPrior();\\r\\n            uint256 cashPlusBorrowsMinusReserves = totalCash +\\r\\n                totalBorrows -\\r\\n                totalReserves;\\r\\n            uint256 exchangeRate = (cashPlusBorrowsMinusReserves * expScale) /\\r\\n                _totalSupply;\\r\\n\\r\\n            return exchangeRate;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get cash balance of this cToken in the underlying asset\\r\\n     * @return The quantity of underlying asset owned by this contract\\r\\n     */\\r\\n    function getCash() external view override returns (uint256) {\\r\\n        return getCashPrior();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Applies accrued interest to total borrows and reserves\\r\\n     * @dev This calculates interest accrued from the last checkpointed block\\r\\n     *   up to the current block and writes new checkpoint to storage.\\r\\n     */\\r\\n    function accrueInterest() public virtual override returns (uint256) {\\r\\n        /* Remember the initial block number */\\r\\n        uint256 currentBlockNumber = getBlockNumber();\\r\\n        uint256 accrualBlockNumberPrior = accrualBlockNumber;\\r\\n\\r\\n        /* Short-circuit accumulating 0 interest */\\r\\n        if (accrualBlockNumberPrior == currentBlockNumber) {\\r\\n            return NO_ERROR;\\r\\n        }\\r\\n\\r\\n        /* Read the previous values out of storage */\\r\\n        uint256 cashPrior = getCashPrior();\\r\\n        uint256 borrowsPrior = totalBorrows;\\r\\n        uint256 reservesPrior = totalReserves;\\r\\n        uint256 borrowIndexPrior = borrowIndex;\\r\\n\\r\\n        /* Calculate the current borrow interest rate */\\r\\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate(\\r\\n            cashPrior,\\r\\n            borrowsPrior,\\r\\n            reservesPrior\\r\\n        );\\r\\n        require(\\r\\n            borrowRateMantissa <= borrowRateMaxMantissa,\\r\\n            \\\"borrow rate is absurdly high\\\"\\r\\n        );\\r\\n\\r\\n        /* Calculate the number of blocks elapsed since the last accrual */\\r\\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumberPrior;\\r\\n\\r\\n        /*\\r\\n         * Calculate the interest accumulated into borrows and reserves and the new index:\\r\\n         *  simpleInterestFactor = borrowRate * blockDelta\\r\\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\\r\\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\\r\\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\\r\\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\\r\\n         */\\r\\n\\r\\n        Exp memory simpleInterestFactor = mul_(\\r\\n            Exp({mantissa: borrowRateMantissa}),\\r\\n            blockDelta\\r\\n        );\\r\\n        uint256 interestAccumulated = mul_ScalarTruncate(\\r\\n            simpleInterestFactor,\\r\\n            borrowsPrior\\r\\n        );\\r\\n        uint256 totalBorrowsNew = interestAccumulated + borrowsPrior;\\r\\n        uint256 totalReservesNew = mul_ScalarTruncateAddUInt(\\r\\n            Exp({mantissa: reserveFactorMantissa}),\\r\\n            interestAccumulated,\\r\\n            reservesPrior\\r\\n        );\\r\\n        uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(\\r\\n            simpleInterestFactor,\\r\\n            borrowIndexPrior,\\r\\n            borrowIndexPrior\\r\\n        );\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /* We write the previously calculated values into storage */\\r\\n        accrualBlockNumber = currentBlockNumber;\\r\\n        borrowIndex = borrowIndexNew;\\r\\n        totalBorrows = totalBorrowsNew;\\r\\n        totalReserves = totalReservesNew;\\r\\n\\r\\n        /* We emit an AccrueInterest event */\\r\\n        emit AccrueInterest(\\r\\n            cashPrior,\\r\\n            interestAccumulated,\\r\\n            borrowIndexNew,\\r\\n            totalBorrowsNew\\r\\n        );\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param mintAmount The amount of the underlying asset to supply\\r\\n     */\\r\\n    function mintInternal(uint256 mintAmount) internal nonReentrant {\\r\\n        accrueInterest();\\r\\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\r\\n        mintFresh(msg.sender, mintAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice User supplies assets into the market and receives cTokens in exchange\\r\\n     * @dev Assumes interest has already been accrued up to the current block\\r\\n     * @param minter The address of the account which is supplying the assets\\r\\n     * @param mintAmount The amount of the underlying asset to supply\\r\\n     */\\r\\n    function mintFresh(address minter, uint256 mintAmount) internal {\\r\\n        /* Fail if mint not allowed */\\r\\n        uint256 allowed = comptroller.mintAllowed(\\r\\n            address(this),\\r\\n            minter,\\r\\n            mintAmount\\r\\n        );\\r\\n        if (allowed != 0) {\\r\\n            revert MintComptrollerRejection(allowed);\\r\\n        }\\r\\n\\r\\n        /* Verify market's block number equals current block number */\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            revert MintFreshnessCheck();\\r\\n        }\\r\\n\\r\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /*\\r\\n         *  We call `doTransferIn` for the minter and the mintAmount.\\r\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\r\\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\\r\\n         *  side-effects occurred. The function returns the amount actually transferred,\\r\\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\\r\\n         *  of cash.\\r\\n         */\\r\\n        uint256 actualMintAmount = doTransferIn(minter, mintAmount);\\r\\n\\r\\n        /*\\r\\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\\r\\n         *  mintTokens = actualMintAmount / exchangeRate\\r\\n         */\\r\\n\\r\\n        uint256 mintTokens = div_(actualMintAmount, exchangeRate);\\r\\n\\r\\n        // avoid exchangeRate manipulation\\r\\n        if (totalSupply == 0) {\\r\\n            totalSupply = 1000;\\r\\n            accountTokens[address(0)] = 1000;\\r\\n            mintTokens -= 1000;\\r\\n        }\\r\\n\\r\\n        /*\\r\\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\\r\\n         *  totalSupplyNew = totalSupply + mintTokens\\r\\n         *  accountTokensNew = accountTokens[minter] + mintTokens\\r\\n         * And write them into storage\\r\\n         */\\r\\n        totalSupply = totalSupply + mintTokens;\\r\\n        accountTokens[minter] = accountTokens[minter] + mintTokens;\\r\\n\\r\\n        /* We emit a Mint event, and a Transfer event */\\r\\n        emit Mint(minter, actualMintAmount, mintTokens);\\r\\n        emit Transfer(address(this), minter, mintTokens);\\r\\n\\r\\n        /* We call the defense hook */\\r\\n\\r\\n        comptroller.mintVerify(\\r\\n            address(this),\\r\\n            minter,\\r\\n            actualMintAmount,\\r\\n            mintTokens\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems cTokens in exchange for the underlying asset\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param redeemTokens The number of cTokens to redeem into underlying\\r\\n     */\\r\\n    function redeemInternal(uint256 redeemTokens) internal nonReentrant {\\r\\n        accrueInterest();\\r\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\r\\n        redeemFresh(payable(msg.sender), redeemTokens, 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\\r\\n     */\\r\\n    function redeemUnderlyingInternal(\\r\\n        uint256 redeemAmount\\r\\n    ) internal nonReentrant {\\r\\n        accrueInterest();\\r\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\r\\n        redeemFresh(payable(msg.sender), 0, redeemAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice User redeems cTokens in exchange for the underlying asset\\r\\n     * @dev Assumes interest has already been accrued up to the current block\\r\\n     * @param redeemer The address of the account which is redeeming the tokens\\r\\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\r\\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\r\\n     */\\r\\n    function redeemFresh(\\r\\n        address payable redeemer,\\r\\n        uint256 redeemTokensIn,\\r\\n        uint256 redeemAmountIn\\r\\n    ) internal {\\r\\n        require(\\r\\n            redeemTokensIn == 0 || redeemAmountIn == 0,\\r\\n            \\\"one of redeemTokensIn or redeemAmountIn must be zero\\\"\\r\\n        );\\r\\n\\r\\n        /* exchangeRate = invoke Exchange Rate Stored() */\\r\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\\r\\n\\r\\n        uint256 redeemTokens;\\r\\n        uint256 redeemAmount;\\r\\n        /* If redeemTokensIn > 0: */\\r\\n        if (redeemTokensIn > 0) {\\r\\n            /*\\r\\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\\r\\n             *  redeemTokens = redeemTokensIn\\r\\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\\r\\n             */\\r\\n            redeemTokens = redeemTokensIn;\\r\\n            redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\\r\\n        } else {\\r\\n            /*\\r\\n             * We get the current exchange rate and calculate the amount to be redeemed:\\r\\n             *  redeemTokens = redeemAmountIn / exchangeRate\\r\\n             *  redeemAmount = redeemAmountIn\\r\\n             */\\r\\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\\r\\n            redeemAmount = redeemAmountIn;\\r\\n        }\\r\\n\\r\\n        /* Fail if redeem not allowed */\\r\\n        uint256 allowed = comptroller.redeemAllowed(\\r\\n            address(this),\\r\\n            redeemer,\\r\\n            redeemTokens\\r\\n        );\\r\\n        if (allowed != 0) {\\r\\n            revert RedeemComptrollerRejection(allowed);\\r\\n        }\\r\\n\\r\\n        /* Verify market's block number equals current block number */\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            revert RedeemFreshnessCheck();\\r\\n        }\\r\\n\\r\\n        /* Fail gracefully if protocol has insufficient cash */\\r\\n        if (getCashPrior() < redeemAmount) {\\r\\n            revert RedeemTransferOutNotPossible();\\r\\n        }\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /*\\r\\n         * We write the previously calculated values into storage.\\r\\n         *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\\r\\n         */\\r\\n        totalSupply = totalSupply - redeemTokens;\\r\\n        accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\\r\\n\\r\\n        /*\\r\\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\\r\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\r\\n         *  On success, the cToken has redeemAmount less of cash.\\r\\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n         */\\r\\n        doTransferOut(redeemer, redeemAmount);\\r\\n\\r\\n        /* We emit a Transfer event, and a Redeem event */\\r\\n        emit Transfer(redeemer, address(this), redeemTokens);\\r\\n        emit Redeem(redeemer, redeemAmount, redeemTokens);\\r\\n\\r\\n        /* We call the defense hook */\\r\\n        comptroller.redeemVerify(\\r\\n            address(this),\\r\\n            redeemer,\\r\\n            redeemAmount,\\r\\n            redeemTokens\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender borrows assets from the protocol to their own address\\r\\n     * @param borrowAmount The amount of the underlying asset to borrow\\r\\n     */\\r\\n    function borrowInternal(uint256 borrowAmount) internal nonReentrant {\\r\\n        accrueInterest();\\r\\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\\r\\n        borrowFresh(payable(msg.sender), borrowAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Users borrow assets from the protocol to their own address\\r\\n     * @param borrowAmount The amount of the underlying asset to borrow\\r\\n     */\\r\\n    function borrowFresh(\\r\\n        address payable borrower,\\r\\n        uint256 borrowAmount\\r\\n    ) internal {\\r\\n        /* Fail if borrow not allowed */\\r\\n        uint256 allowed = comptroller.borrowAllowed(\\r\\n            address(this),\\r\\n            borrower,\\r\\n            borrowAmount\\r\\n        );\\r\\n        if (allowed != 0) {\\r\\n            revert BorrowComptrollerRejection(allowed);\\r\\n        }\\r\\n\\r\\n        /* Verify market's block number equals current block number */\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            revert BorrowFreshnessCheck();\\r\\n        }\\r\\n\\r\\n        /* Fail gracefully if protocol has insufficient underlying cash */\\r\\n        if (getCashPrior() < borrowAmount) {\\r\\n            revert BorrowCashNotAvailable();\\r\\n        }\\r\\n\\r\\n        /*\\r\\n         * We calculate the new borrower and total borrow balances, failing on overflow:\\r\\n         *  accountBorrowNew = accountBorrow + borrowAmount\\r\\n         *  totalBorrowsNew = totalBorrows + borrowAmount\\r\\n         */\\r\\n        uint256 accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\\r\\n        uint256 accountBorrowsNew = accountBorrowsPrev + borrowAmount;\\r\\n        uint256 totalBorrowsNew = totalBorrows + borrowAmount;\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /*\\r\\n         * We write the previously calculated values into storage.\\r\\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\\r\\n        `*/\\r\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\r\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\r\\n        totalBorrows = totalBorrowsNew;\\r\\n\\r\\n        /*\\r\\n         * We invoke doTransferOut for the borrower and the borrowAmount.\\r\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\r\\n         *  On success, the cToken borrowAmount less of cash.\\r\\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n         */\\r\\n        doTransferOut(borrower, borrowAmount);\\r\\n\\r\\n        /* We emit a Borrow event */\\r\\n        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender repays their own borrow\\r\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\r\\n     */\\r\\n    function repayBorrowInternal(uint256 repayAmount) internal nonReentrant {\\r\\n        accrueInterest();\\r\\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\r\\n        repayBorrowFresh(msg.sender, msg.sender, repayAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender repays a borrow belonging to borrower\\r\\n     * @param borrower the account with the debt being payed off\\r\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\r\\n     */\\r\\n    function repayBorrowBehalfInternal(\\r\\n        address borrower,\\r\\n        uint256 repayAmount\\r\\n    ) internal nonReentrant {\\r\\n        accrueInterest();\\r\\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\r\\n        repayBorrowFresh(msg.sender, borrower, repayAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Borrows are repaid by another user (possibly the borrower).\\r\\n     * @param payer the account paying off the borrow\\r\\n     * @param borrower the account with the debt being payed off\\r\\n     * @param repayAmount the amount of underlying tokens being returned, or -1 for the full outstanding amount\\r\\n     * @return (uint) the actual repayment amount.\\r\\n     */\\r\\n    function repayBorrowFresh(\\r\\n        address payer,\\r\\n        address borrower,\\r\\n        uint256 repayAmount\\r\\n    ) internal returns (uint256) {\\r\\n        /* Fail if repayBorrow not allowed */\\r\\n        uint256 allowed = comptroller.repayBorrowAllowed(\\r\\n            address(this),\\r\\n            payer,\\r\\n            borrower,\\r\\n            repayAmount\\r\\n        );\\r\\n        if (allowed != 0) {\\r\\n            revert RepayBorrowComptrollerRejection(allowed);\\r\\n        }\\r\\n\\r\\n        /* Verify market's block number equals current block number */\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            revert RepayBorrowFreshnessCheck();\\r\\n        }\\r\\n\\r\\n        /* We fetch the amount the borrower owes, with accumulated interest */\\r\\n        uint256 accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\\r\\n\\r\\n        /* If repayAmount == -1, repayAmount = accountBorrows */\\r\\n        uint256 repayAmountFinal = repayAmount == type(uint256).max\\r\\n            ? accountBorrowsPrev\\r\\n            : repayAmount;\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /*\\r\\n         * We call doTransferIn for the payer and the repayAmount\\r\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\r\\n         *  On success, the cToken holds an additional repayAmount of cash.\\r\\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n         *   it returns the amount actually transferred, in case of a fee.\\r\\n         */\\r\\n        uint256 actualRepayAmount = doTransferIn(payer, repayAmountFinal);\\r\\n\\r\\n        /*\\r\\n         * We calculate the new borrower and total borrow balances, failing on underflow:\\r\\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\\r\\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\\r\\n         */\\r\\n        uint256 accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\\r\\n        uint256 totalBorrowsNew = totalBorrows - actualRepayAmount;\\r\\n\\r\\n        /* We write the previously calculated values into storage */\\r\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\r\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\r\\n        totalBorrows = totalBorrowsNew;\\r\\n\\r\\n        /* We emit a RepayBorrow event */\\r\\n        emit RepayBorrow(\\r\\n            payer,\\r\\n            borrower,\\r\\n            actualRepayAmount,\\r\\n            accountBorrowsNew,\\r\\n            totalBorrowsNew\\r\\n        );\\r\\n\\r\\n        return actualRepayAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The sender liquidates the borrowers collateral.\\r\\n     *  The collateral seized is transferred to the liquidator.\\r\\n     * @param borrower The borrower of this cToken to be liquidated\\r\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\r\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\r\\n     */\\r\\n    function liquidateBorrowInternal(\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        CTokenInterface cTokenCollateral\\r\\n    ) internal nonReentrant {\\r\\n        accrueInterest();\\r\\n\\r\\n        uint256 error = cTokenCollateral.accrueInterest();\\r\\n        if (error != NO_ERROR) {\\r\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\\r\\n            revert LiquidateAccrueCollateralInterestFailed(error);\\r\\n        }\\r\\n\\r\\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\\r\\n        liquidateBorrowFresh(\\r\\n            msg.sender,\\r\\n            borrower,\\r\\n            repayAmount,\\r\\n            cTokenCollateral\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The liquidator liquidates the borrowers collateral.\\r\\n     *  The collateral seized is transferred to the liquidator.\\r\\n     * @param borrower The borrower of this cToken to be liquidated\\r\\n     * @param liquidator The address repaying the borrow and seizing collateral\\r\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\r\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\r\\n     */\\r\\n    function liquidateBorrowFresh(\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        CTokenInterface cTokenCollateral\\r\\n    ) internal {\\r\\n        /* Fail if liquidate not allowed */\\r\\n        uint256 allowed = comptroller.liquidateBorrowAllowed(\\r\\n            address(this),\\r\\n            address(cTokenCollateral),\\r\\n            liquidator,\\r\\n            borrower,\\r\\n            repayAmount\\r\\n        );\\r\\n        if (allowed != 0) {\\r\\n            revert LiquidateComptrollerRejection(allowed);\\r\\n        }\\r\\n\\r\\n        /* Verify market's block number equals current block number */\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            revert LiquidateFreshnessCheck();\\r\\n        }\\r\\n\\r\\n        /* Verify cTokenCollateral market's block number equals current block number */\\r\\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\\r\\n            revert LiquidateCollateralFreshnessCheck();\\r\\n        }\\r\\n\\r\\n        /* Fail if borrower = liquidator */\\r\\n        if (borrower == liquidator) {\\r\\n            revert LiquidateLiquidatorIsBorrower();\\r\\n        }\\r\\n\\r\\n        /* Fail if repayAmount = 0 */\\r\\n        if (repayAmount == 0) {\\r\\n            revert LiquidateCloseAmountIsZero();\\r\\n        }\\r\\n\\r\\n        /* Fail if repayAmount = -1 */\\r\\n        if (repayAmount == type(uint256).max) {\\r\\n            revert LiquidateCloseAmountIsUintMax();\\r\\n        }\\r\\n\\r\\n        /* Fail if repayBorrow fails */\\r\\n        uint256 actualRepayAmount = repayBorrowFresh(\\r\\n            liquidator,\\r\\n            borrower,\\r\\n            repayAmount\\r\\n        );\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /* We calculate the number of collateral tokens that will be seized */\\r\\n        (uint256 amountSeizeError, uint256 seizeTokens) = comptroller\\r\\n            .liquidateCalculateSeizeTokens(\\r\\n                address(this),\\r\\n                address(cTokenCollateral),\\r\\n                actualRepayAmount\\r\\n            );\\r\\n        require(\\r\\n            amountSeizeError == NO_ERROR,\\r\\n            \\\"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\\\"\\r\\n        );\\r\\n\\r\\n        /* Revert if borrower collateral token balance < seizeTokens */\\r\\n        require(\\r\\n            cTokenCollateral.balanceOf(borrower) >= seizeTokens,\\r\\n            \\\"LIQUIDATE_SEIZE_TOO_MUCH\\\"\\r\\n        );\\r\\n\\r\\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\\r\\n        if (address(cTokenCollateral) == address(this)) {\\r\\n            seizeInternal(address(this), liquidator, borrower, seizeTokens);\\r\\n        } else {\\r\\n            require(\\r\\n                cTokenCollateral.seize(liquidator, borrower, seizeTokens) ==\\r\\n                    NO_ERROR,\\r\\n                \\\"token seizure failed\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        /* We emit a LiquidateBorrow event */\\r\\n        emit LiquidateBorrow(\\r\\n            liquidator,\\r\\n            borrower,\\r\\n            actualRepayAmount,\\r\\n            address(cTokenCollateral),\\r\\n            seizeTokens\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\r\\n     * @dev Will fail unless called by another cToken during the process of liquidation.\\r\\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\\r\\n     * @param liquidator The account receiving seized collateral\\r\\n     * @param borrower The account having collateral seized\\r\\n     * @param seizeTokens The number of cTokens to seize\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function seize(\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint256 seizeTokens\\r\\n    ) external override nonReentrant returns (uint256) {\\r\\n        seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\r\\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\\r\\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\\r\\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\\r\\n     * @param liquidator The account receiving seized collateral\\r\\n     * @param borrower The account having collateral seized\\r\\n     * @param seizeTokens The number of cTokens to seize\\r\\n     */\\r\\n    function seizeInternal(\\r\\n        address seizerToken,\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint256 seizeTokens\\r\\n    ) internal {\\r\\n        /* Fail if seize not allowed */\\r\\n        uint256 allowed = comptroller.seizeAllowed(\\r\\n            address(this),\\r\\n            seizerToken,\\r\\n            liquidator,\\r\\n            borrower,\\r\\n            seizeTokens\\r\\n        );\\r\\n        if (allowed != 0) {\\r\\n            revert LiquidateSeizeComptrollerRejection(allowed);\\r\\n        }\\r\\n\\r\\n        /* Fail if borrower = liquidator */\\r\\n        if (borrower == liquidator) {\\r\\n            revert LiquidateSeizeLiquidatorIsBorrower();\\r\\n        }\\r\\n\\r\\n        /*\\r\\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\\r\\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\\r\\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\\r\\n         */\\r\\n        uint256 protocolSeizeTokens = mul_(\\r\\n            seizeTokens,\\r\\n            Exp({mantissa: protocolSeizeShareMantissa})\\r\\n        );\\r\\n        uint256 liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\\r\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\\r\\n        uint256 protocolSeizeAmount = mul_ScalarTruncate(\\r\\n            exchangeRate,\\r\\n            protocolSeizeTokens\\r\\n        );\\r\\n        uint256 totalReservesNew = totalReserves + protocolSeizeAmount;\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /* We write the calculated values into storage */\\r\\n        totalReserves = totalReservesNew;\\r\\n        totalSupply = totalSupply - protocolSeizeTokens;\\r\\n        accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\\r\\n        accountTokens[liquidator] =\\r\\n            accountTokens[liquidator] +\\r\\n            liquidatorSeizeTokens;\\r\\n\\r\\n        /* Emit a Transfer event */\\r\\n        emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\\r\\n        emit Transfer(borrower, address(this), protocolSeizeTokens);\\r\\n        emit ReservesAdded(\\r\\n            address(this),\\r\\n            protocolSeizeAmount,\\r\\n            totalReservesNew\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\r\\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\r\\n     * @param newPendingAdmin New pending admin.\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _setPendingAdmin(\\r\\n        address payable newPendingAdmin\\r\\n    ) external override returns (uint256) {\\r\\n        // Check caller = admin\\r\\n        if (msg.sender != admin) {\\r\\n            revert SetPendingAdminOwnerCheck();\\r\\n        }\\r\\n\\r\\n        // Save current value, if any, for inclusion in log\\r\\n        address oldPendingAdmin = pendingAdmin;\\r\\n\\r\\n        // Store pendingAdmin with value newPendingAdmin\\r\\n        pendingAdmin = newPendingAdmin;\\r\\n\\r\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\r\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\r\\n     * @dev Admin function for pending admin to accept role and update admin\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _acceptAdmin() external override returns (uint256) {\\r\\n        // Check caller is pendingAdmin and pendingAdmin \\u2260 address(0)\\r\\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\\r\\n            revert AcceptAdminPendingAdminCheck();\\r\\n        }\\r\\n\\r\\n        // Save current values for inclusion in log\\r\\n        address oldAdmin = admin;\\r\\n        address oldPendingAdmin = pendingAdmin;\\r\\n\\r\\n        // Store admin with value pendingAdmin\\r\\n        admin = pendingAdmin;\\r\\n\\r\\n        // Clear the pending value\\r\\n        pendingAdmin = payable(address(0));\\r\\n\\r\\n        emit NewAdmin(oldAdmin, admin);\\r\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets a new comptroller for the market\\r\\n     * @dev Admin function to set a new comptroller\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _setComptroller(\\r\\n        ComptrollerInterface newComptroller\\r\\n    ) public override returns (uint256) {\\r\\n        // Check caller is admin\\r\\n        if (msg.sender != admin) {\\r\\n            revert SetComptrollerOwnerCheck();\\r\\n        }\\r\\n\\r\\n        ComptrollerInterface oldComptroller = comptroller;\\r\\n        // Ensure invoke comptroller.isComptroller() returns true\\r\\n        require(newComptroller.isComptroller(), \\\"marker method returned false\\\");\\r\\n\\r\\n        // Set market's comptroller to newComptroller\\r\\n        comptroller = newComptroller;\\r\\n\\r\\n        // Emit NewComptroller(oldComptroller, newComptroller)\\r\\n        emit NewComptroller(oldComptroller, newComptroller);\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\r\\n     * @dev Admin function to accrue interest and set a new reserve factor\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _setReserveFactor(\\r\\n        uint256 newReserveFactorMantissa\\r\\n    ) external override nonReentrant returns (uint256) {\\r\\n        accrueInterest();\\r\\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\\r\\n        return _setReserveFactorFresh(newReserveFactorMantissa);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\\r\\n     * @dev Admin function to set a new reserve factor\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _setReserveFactorFresh(\\r\\n        uint256 newReserveFactorMantissa\\r\\n    ) internal returns (uint256) {\\r\\n        // Check caller is admin\\r\\n        if (msg.sender != admin) {\\r\\n            revert SetReserveFactorAdminCheck();\\r\\n        }\\r\\n\\r\\n        // Verify market's block number equals current block number\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            revert SetReserveFactorFreshCheck();\\r\\n        }\\r\\n\\r\\n        // Check newReserveFactor \\u2264 maxReserveFactor\\r\\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\\r\\n            revert SetReserveFactorBoundsCheck();\\r\\n        }\\r\\n\\r\\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\\r\\n        reserveFactorMantissa = newReserveFactorMantissa;\\r\\n\\r\\n        emit NewReserveFactor(\\r\\n            oldReserveFactorMantissa,\\r\\n            newReserveFactorMantissa\\r\\n        );\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\\r\\n     * @param addAmount Amount of addition to reserves\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _addReservesInternal(\\r\\n        uint256 addAmount\\r\\n    ) internal nonReentrant returns (uint256) {\\r\\n        accrueInterest();\\r\\n\\r\\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\\r\\n        _addReservesFresh(addAmount);\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add reserves by transferring from caller\\r\\n     * @dev Requires fresh interest accrual\\r\\n     * @param addAmount Amount of addition to reserves\\r\\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\\r\\n     */\\r\\n    function _addReservesFresh(\\r\\n        uint256 addAmount\\r\\n    ) internal returns (uint256, uint256) {\\r\\n        // totalReserves + actualAddAmount\\r\\n        uint256 totalReservesNew;\\r\\n        uint256 actualAddAmount;\\r\\n\\r\\n        // We fail gracefully unless market's block number equals current block number\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            revert AddReservesFactorFreshCheck(actualAddAmount);\\r\\n        }\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /*\\r\\n         * We call doTransferIn for the caller and the addAmount\\r\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\r\\n         *  On success, the cToken holds an additional addAmount of cash.\\r\\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n         *  it returns the amount actually transferred, in case of a fee.\\r\\n         */\\r\\n\\r\\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\\r\\n\\r\\n        totalReservesNew = totalReserves + actualAddAmount;\\r\\n\\r\\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\\r\\n        totalReserves = totalReservesNew;\\r\\n\\r\\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\\r\\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\\r\\n\\r\\n        /* Return (NO_ERROR, actualAddAmount) */\\r\\n        return (NO_ERROR, actualAddAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Admin function to set new reserve guardian\\r\\n     * @param newReserveGuardian New reserve guardian address\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _setReserveGuardian(\\r\\n        address payable newReserveGuardian\\r\\n    ) external returns (uint256) {\\r\\n        // Check caller is admin\\r\\n        if (msg.sender != admin) {\\r\\n            revert SetReserveGuardianOwnerCheck();\\r\\n        }\\r\\n\\r\\n        // Save current value, if any, for inclusion in log\\r\\n        address oldReserveGuardian = reserveGuardian;\\r\\n\\r\\n        // Set market's reserveGuardian to newReserveGuardian\\r\\n        reserveGuardian = newReserveGuardian;\\r\\n\\r\\n        emit NewReserveGuardian(oldReserveGuardian, newReserveGuardian);\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrues interest and reduces reserves by transferring to admin\\r\\n     * @param reduceAmount Amount of reduction to reserves\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _reduceReserves(\\r\\n        uint256 reduceAmount\\r\\n    ) external override nonReentrant returns (uint256) {\\r\\n        accrueInterest();\\r\\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\\r\\n        return _reduceReservesFresh(reduceAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reduces reserves by transferring to admin\\r\\n     * @dev Requires fresh interest accrual\\r\\n     * @param reduceAmount Amount of reduction to reserves\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _reduceReservesFresh(\\r\\n        uint256 reduceAmount\\r\\n    ) internal returns (uint256) {\\r\\n        // totalReserves - reduceAmount\\r\\n        uint256 totalReservesNew;\\r\\n\\r\\n        // Check caller is admin\\r\\n        // TODO: Fix\\r\\n        if (msg.sender != admin && msg.sender != reserveGuardian) {\\r\\n            revert ReduceReservesAdminCheck();\\r\\n        }\\r\\n\\r\\n        // We fail gracefully unless market's block number equals current block number\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            revert ReduceReservesFreshCheck();\\r\\n        }\\r\\n\\r\\n        // Fail gracefully if protocol has insufficient underlying cash\\r\\n        if (getCashPrior() < reduceAmount) {\\r\\n            revert ReduceReservesCashNotAvailable();\\r\\n        }\\r\\n\\r\\n        // Check reduceAmount \\u2264 reserves[n] (totalReserves)\\r\\n        if (reduceAmount > totalReserves) {\\r\\n            revert ReduceReservesCashValidation();\\r\\n        }\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        totalReservesNew = totalReserves - reduceAmount;\\r\\n\\r\\n        // Store reserves[n+1] = reserves[n] - reduceAmount\\r\\n        totalReserves = totalReservesNew;\\r\\n\\r\\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n        doTransferOut(payable(msg.sender), reduceAmount);\\r\\n\\r\\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\\r\\n     * @dev Admin function to accrue interest and update the interest rate model\\r\\n     * @param newInterestRateModel the new interest rate model to use\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _setInterestRateModel(\\r\\n        InterestRateModel newInterestRateModel\\r\\n    ) public override returns (uint256) {\\r\\n        accrueInterest();\\r\\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\\r\\n        return _setInterestRateModelFresh(newInterestRateModel);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice updates the interest rate model (*requires fresh interest accrual)\\r\\n     * @dev Admin function to update the interest rate model\\r\\n     * @param newInterestRateModel the new interest rate model to use\\r\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\r\\n     */\\r\\n    function _setInterestRateModelFresh(\\r\\n        InterestRateModel newInterestRateModel\\r\\n    ) internal returns (uint256) {\\r\\n        // Used to store old model for use in the event that is emitted on success\\r\\n        InterestRateModel oldInterestRateModel;\\r\\n\\r\\n        // Check caller is admin\\r\\n        if (msg.sender != admin) {\\r\\n            revert SetInterestRateModelOwnerCheck();\\r\\n        }\\r\\n\\r\\n        // We fail gracefully unless market's block number equals current block number\\r\\n        if (accrualBlockNumber != getBlockNumber()) {\\r\\n            revert SetInterestRateModelFreshCheck();\\r\\n        }\\r\\n\\r\\n        // Track the market's current interest rate model\\r\\n        oldInterestRateModel = interestRateModel;\\r\\n\\r\\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\\r\\n        require(\\r\\n            newInterestRateModel.isInterestRateModel(),\\r\\n            \\\"marker method returned false\\\"\\r\\n        );\\r\\n\\r\\n        // Set the interest rate model to newInterestRateModel\\r\\n        interestRateModel = newInterestRateModel;\\r\\n\\r\\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\\r\\n        emit NewMarketInterestRateModel(\\r\\n            oldInterestRateModel,\\r\\n            newInterestRateModel\\r\\n        );\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /*** Safe Token ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Gets balance of this contract in terms of the underlying\\r\\n     * @dev This excludes the value of the current message, if any\\r\\n     * @return The quantity of underlying owned by this contract\\r\\n     */\\r\\n    function getCashPrior() internal view virtual returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\\r\\n     *  This may revert due to insufficient balance or insufficient allowance.\\r\\n     */\\r\\n    function doTransferIn(\\r\\n        address from,\\r\\n        uint256 amount\\r\\n    ) internal virtual returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\\r\\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\\r\\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\\r\\n     */\\r\\n    function doTransferOut(address payable to, uint256 amount) internal virtual;\\r\\n\\r\\n    /*** Reentrancy Guard ***/\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        require(_notEntered, \\\"re-entered\\\");\\r\\n        _notEntered = false;\\r\\n        _;\\r\\n        _notEntered = true; // get a gas-refund post-Istanbul\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x5e1c0d9425ff424f90cf68ebbc4ab38b28fff477f5032a4e4b09d85fb444f75e\",\"license\":\"BSD-3-Clause\"},\"contracts/CTokenInterfaces.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\nimport \\\"./ComptrollerInterface.sol\\\";\\r\\nimport \\\"./InterestRateModel.sol\\\";\\r\\nimport \\\"./EIP20NonStandardInterface.sol\\\";\\r\\nimport \\\"./ErrorReporter.sol\\\";\\r\\n\\r\\ncontract CTokenStorage {\\r\\n    /**\\r\\n     * @dev Guard variable for re-entrancy checks\\r\\n     */\\r\\n    bool internal _notEntered;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token name for this token\\r\\n     */\\r\\n    string public name;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token symbol for this token\\r\\n     */\\r\\n    string public symbol;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token decimals for this token\\r\\n     */\\r\\n    uint8 public decimals;\\r\\n\\r\\n    // Maximum borrow rate that can ever be applied (.0005% / block)\\r\\n    uint internal constant borrowRateMaxMantissa = 0.00004e16;\\r\\n\\r\\n    // Maximum fraction of interest that can be set aside for reserves\\r\\n    uint internal constant reserveFactorMaxMantissa = 1e18;\\r\\n\\r\\n    /**\\r\\n     * @notice Administrator for this contract\\r\\n     */\\r\\n    address payable public admin;\\r\\n\\r\\n    /**\\r\\n     * @notice Pending administrator for this contract\\r\\n     */\\r\\n    address payable public pendingAdmin;\\r\\n\\r\\n    /**\\r\\n     * @notice Contract which oversees inter-cToken operations\\r\\n     */\\r\\n    ComptrollerInterface public comptroller;\\r\\n\\r\\n    /**\\r\\n     * @notice Model which tells what the current interest rate should be\\r\\n     */\\r\\n    InterestRateModel public interestRateModel;\\r\\n\\r\\n    // Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\\r\\n    uint internal initialExchangeRateMantissa;\\r\\n\\r\\n    /**\\r\\n     * @notice Fraction of interest currently set aside for reserves\\r\\n     */\\r\\n    uint public reserveFactorMantissa;\\r\\n\\r\\n    /**\\r\\n     * @notice Block number that interest was last accrued at\\r\\n     */\\r\\n    uint public accrualBlockNumber;\\r\\n\\r\\n    /**\\r\\n     * @notice Accumulator of the total earned interest rate since the opening of the market\\r\\n     */\\r\\n    uint public borrowIndex;\\r\\n\\r\\n    /**\\r\\n     * @notice Total amount of outstanding borrows of the underlying in this market\\r\\n     */\\r\\n    uint public totalBorrows;\\r\\n\\r\\n    /**\\r\\n     * @notice Total amount of reserves of the underlying held in this market\\r\\n     */\\r\\n    uint public totalReserves;\\r\\n\\r\\n    /**\\r\\n     * @notice Total number of tokens in circulation\\r\\n     */\\r\\n    uint public totalSupply;\\r\\n\\r\\n    // Official record of token balances for each account\\r\\n    mapping(address => uint) internal accountTokens;\\r\\n\\r\\n    // Approved token transfer amounts on behalf of others\\r\\n    mapping(address => mapping(address => uint)) internal transferAllowances;\\r\\n\\r\\n    /**\\r\\n     * @notice Container for borrow balance information\\r\\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\r\\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\r\\n     */\\r\\n    struct BorrowSnapshot {\\r\\n        uint principal;\\r\\n        uint interestIndex;\\r\\n    }\\r\\n\\r\\n    // Mapping of account addresses to outstanding borrow balances\\r\\n    mapping(address => BorrowSnapshot) internal accountBorrows;\\r\\n\\r\\n    /**\\r\\n     * @notice Share of seized collateral that is added to reserves\\r\\n     */\\r\\n    uint public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\\r\\n\\r\\n    /**\\r\\n     * @notice The reserve guardian can reduce the reserves of the market\\r\\n     */\\r\\n    address payable public reserveGuardian;\\r\\n}\\r\\n\\r\\nabstract contract CTokenInterface is CTokenStorage {\\r\\n    /**\\r\\n     * @notice Indicator that this is a CToken contract (for inspection)\\r\\n     */\\r\\n    bool public constant isCToken = true;\\r\\n\\r\\n    /*** Market Events ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when interest is accrued\\r\\n     */\\r\\n    event AccrueInterest(\\r\\n        uint cashPrior,\\r\\n        uint interestAccumulated,\\r\\n        uint borrowIndex,\\r\\n        uint totalBorrows\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when tokens are minted\\r\\n     */\\r\\n    event Mint(address minter, uint mintAmount, uint mintTokens);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when tokens are redeemed\\r\\n     */\\r\\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when underlying is borrowed\\r\\n     */\\r\\n    event Borrow(\\r\\n        address borrower,\\r\\n        uint borrowAmount,\\r\\n        uint accountBorrows,\\r\\n        uint totalBorrows\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when a borrow is repaid\\r\\n     */\\r\\n    event RepayBorrow(\\r\\n        address payer,\\r\\n        address borrower,\\r\\n        uint repayAmount,\\r\\n        uint accountBorrows,\\r\\n        uint totalBorrows\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when a borrow is liquidated\\r\\n     */\\r\\n    event LiquidateBorrow(\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint repayAmount,\\r\\n        address cTokenCollateral,\\r\\n        uint seizeTokens\\r\\n    );\\r\\n\\r\\n    /*** Admin Events ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when pendingAdmin is changed\\r\\n     */\\r\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\\r\\n     */\\r\\n    event NewAdmin(address oldAdmin, address newAdmin);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when comptroller is changed\\r\\n     */\\r\\n    event NewComptroller(\\r\\n        ComptrollerInterface oldComptroller,\\r\\n        ComptrollerInterface newComptroller\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when reserve guardian is changed\\r\\n     */\\r\\n    event NewReserveGuardian(\\r\\n        address oldReserveGuardian,\\r\\n        address newReserveGuardian\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when interestRateModel is changed\\r\\n     */\\r\\n    event NewMarketInterestRateModel(\\r\\n        InterestRateModel oldInterestRateModel,\\r\\n        InterestRateModel newInterestRateModel\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when the reserve factor is changed\\r\\n     */\\r\\n    event NewReserveFactor(\\r\\n        uint oldReserveFactorMantissa,\\r\\n        uint newReserveFactorMantissa\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when the reserves are added\\r\\n     */\\r\\n    event ReservesAdded(\\r\\n        address benefactor,\\r\\n        uint addAmount,\\r\\n        uint newTotalReserves\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when the reserves are reduced\\r\\n     */\\r\\n    event ReservesReduced(\\r\\n        address admin,\\r\\n        uint reduceAmount,\\r\\n        uint newTotalReserves\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice EIP20 Transfer event\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint amount);\\r\\n\\r\\n    /**\\r\\n     * @notice EIP20 Approval event\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function transfer(address dst, uint amount) external virtual returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint amount\\r\\n    ) external virtual returns (bool);\\r\\n\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint amount\\r\\n    ) external virtual returns (bool);\\r\\n\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view virtual returns (uint);\\r\\n\\r\\n    function balanceOf(address owner) external view virtual returns (uint);\\r\\n\\r\\n    function balanceOfUnderlying(address owner) external virtual returns (uint);\\r\\n\\r\\n    function getAccountSnapshot(\\r\\n        address account\\r\\n    ) external view virtual returns (uint, uint, uint, uint);\\r\\n\\r\\n    function borrowRatePerBlock() external view virtual returns (uint);\\r\\n\\r\\n    function supplyRatePerBlock() external view virtual returns (uint);\\r\\n\\r\\n    function totalBorrowsCurrent() external virtual returns (uint);\\r\\n\\r\\n    function borrowBalanceCurrent(\\r\\n        address account\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    function borrowBalanceStored(\\r\\n        address account\\r\\n    ) external view virtual returns (uint);\\r\\n\\r\\n    function exchangeRateCurrent() external virtual returns (uint);\\r\\n\\r\\n    function exchangeRateStored() external view virtual returns (uint);\\r\\n\\r\\n    function getCash() external view virtual returns (uint);\\r\\n\\r\\n    function accrueInterest() external virtual returns (uint);\\r\\n\\r\\n    function seize(\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint seizeTokens\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    function _setPendingAdmin(\\r\\n        address payable newPendingAdmin\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    function _acceptAdmin() external virtual returns (uint);\\r\\n\\r\\n    function _setComptroller(\\r\\n        ComptrollerInterface newComptroller\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    function _setReserveFactor(\\r\\n        uint newReserveFactorMantissa\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    function _reduceReserves(uint reduceAmount) external virtual returns (uint);\\r\\n\\r\\n    function _setInterestRateModel(\\r\\n        InterestRateModel newInterestRateModel\\r\\n    ) external virtual returns (uint);\\r\\n}\\r\\n\\r\\ncontract CErc20Storage {\\r\\n    /**\\r\\n     * @notice Underlying asset for this CToken\\r\\n     */\\r\\n    address public underlying;\\r\\n}\\r\\n\\r\\nabstract contract CErc20Interface is CErc20Storage {\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function mint(uint mintAmount) external virtual returns (uint);\\r\\n\\r\\n    function redeem(uint redeemTokens) external virtual returns (uint);\\r\\n\\r\\n    function redeemUnderlying(\\r\\n        uint redeemAmount\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    function borrow(uint borrowAmount) external virtual returns (uint);\\r\\n\\r\\n    function repayBorrow(uint repayAmount) external virtual returns (uint);\\r\\n\\r\\n    function repayBorrowBehalf(\\r\\n        address borrower,\\r\\n        uint repayAmount\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    function liquidateBorrow(\\r\\n        address borrower,\\r\\n        uint repayAmount,\\r\\n        CTokenInterface cTokenCollateral\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    function sweepToken(EIP20NonStandardInterface token) external virtual;\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    function _addReserves(uint addAmount) external virtual returns (uint);\\r\\n}\\r\\n\\r\\ncontract CDelegationStorage {\\r\\n    /**\\r\\n     * @notice Implementation address for this contract\\r\\n     */\\r\\n    address public implementation;\\r\\n}\\r\\n\\r\\nabstract contract CDelegatorInterface is CDelegationStorage {\\r\\n    /**\\r\\n     * @notice Emitted when implementation is changed\\r\\n     */\\r\\n    event NewImplementation(\\r\\n        address oldImplementation,\\r\\n        address newImplementation\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the admin to update the implementation of the delegator\\r\\n     * @param implementation_ The address of the new implementation for delegation\\r\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\r\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\r\\n     */\\r\\n    function _setImplementation(\\r\\n        address implementation_,\\r\\n        bool allowResign,\\r\\n        bytes memory becomeImplementationData\\r\\n    ) external virtual;\\r\\n}\\r\\n\\r\\nabstract contract CDelegateInterface is CDelegationStorage {\\r\\n    /**\\r\\n     * @notice Called by the delegator on a delegate to initialize it for duty\\r\\n     * @dev Should revert if any issues arise which make it unfit for delegation\\r\\n     * @param data The encoded bytes data for any initialization\\r\\n     */\\r\\n    function _becomeImplementation(bytes memory data) external virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\\r\\n     */\\r\\n    function _resignImplementation() external virtual;\\r\\n}\\r\\n\",\"keccak256\":\"0xcdc39e3b76f17de5b2cbe542dcf49693839dad0806815d19d69699f55dbc8445\",\"license\":\"BSD-3-Clause\"},\"contracts/ComptrollerInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\nabstract contract ComptrollerInterface {\\r\\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\\r\\n    bool public constant isComptroller = true;\\r\\n\\r\\n    /*** Assets You Are In ***/\\r\\n\\r\\n    function enterMarkets(\\r\\n        address[] calldata cTokens\\r\\n    ) external virtual returns (uint[] memory);\\r\\n\\r\\n    function exitMarket(address cToken) external virtual returns (uint);\\r\\n\\r\\n    /*** Policy Hooks ***/\\r\\n\\r\\n    function mintAllowed(\\r\\n        address cToken,\\r\\n        address minter,\\r\\n        uint mintAmount\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    function mintVerify(\\r\\n        address cToken,\\r\\n        address minter,\\r\\n        uint mintAmount,\\r\\n        uint mintTokens\\r\\n    ) external virtual;\\r\\n\\r\\n    function redeemAllowed(\\r\\n        address cToken,\\r\\n        address redeemer,\\r\\n        uint redeemTokens\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    function redeemVerify(\\r\\n        address cToken,\\r\\n        address redeemer,\\r\\n        uint redeemAmount,\\r\\n        uint redeemTokens\\r\\n    ) external virtual;\\r\\n\\r\\n    function borrowAllowed(\\r\\n        address cToken,\\r\\n        address borrower,\\r\\n        uint borrowAmount\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    function borrowVerify(\\r\\n        address cToken,\\r\\n        address borrower,\\r\\n        uint borrowAmount\\r\\n    ) external virtual;\\r\\n\\r\\n    function repayBorrowAllowed(\\r\\n        address cToken,\\r\\n        address payer,\\r\\n        address borrower,\\r\\n        uint repayAmount\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    function repayBorrowVerify(\\r\\n        address cToken,\\r\\n        address payer,\\r\\n        address borrower,\\r\\n        uint repayAmount,\\r\\n        uint borrowerIndex\\r\\n    ) external virtual;\\r\\n\\r\\n    function liquidateBorrowAllowed(\\r\\n        address cTokenBorrowed,\\r\\n        address cTokenCollateral,\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint repayAmount\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    function liquidateBorrowVerify(\\r\\n        address cTokenBorrowed,\\r\\n        address cTokenCollateral,\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint repayAmount,\\r\\n        uint seizeTokens\\r\\n    ) external virtual;\\r\\n\\r\\n    function seizeAllowed(\\r\\n        address cTokenCollateral,\\r\\n        address cTokenBorrowed,\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint seizeTokens\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    function seizeVerify(\\r\\n        address cTokenCollateral,\\r\\n        address cTokenBorrowed,\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint seizeTokens\\r\\n    ) external virtual;\\r\\n\\r\\n    function transferAllowed(\\r\\n        address cToken,\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint transferTokens\\r\\n    ) external virtual returns (uint);\\r\\n\\r\\n    function transferVerify(\\r\\n        address cToken,\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint transferTokens\\r\\n    ) external virtual;\\r\\n\\r\\n    /*** Liquidity/Liquidation Calculations ***/\\r\\n\\r\\n    function liquidateCalculateSeizeTokens(\\r\\n        address cTokenBorrowed,\\r\\n        address cTokenCollateral,\\r\\n        uint repayAmount\\r\\n    ) external view virtual returns (uint, uint);\\r\\n}\\r\\n\",\"keccak256\":\"0xdafdd1529146620d7c2d407e7940b7533a1ba241e8d4546b481aef311079ef38\",\"license\":\"BSD-3-Clause\"},\"contracts/EIP20Interface.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\n/**\\r\\n * @title ERC 20 Token Standard Interface\\r\\n *  https://eips.ethereum.org/EIPS/eip-20\\r\\n */\\r\\ninterface EIP20Interface {\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n     * @notice Get the total number of tokens in circulation\\r\\n     * @return The supply of tokens\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the balance of the specified address\\r\\n     * @param owner The address from which the balance will be retrieved\\r\\n     * @return balance The balance\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\r\\n     * @param dst The address of the destination account\\r\\n     * @param amount The number of tokens to transfer\\r\\n     * @return success Whether or not the transfer succeeded\\r\\n     */\\r\\n    function transfer(\\r\\n        address dst,\\r\\n        uint256 amount\\r\\n    ) external returns (bool success);\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\r\\n     * @param src The address of the source account\\r\\n     * @param dst The address of the destination account\\r\\n     * @param amount The number of tokens to transfer\\r\\n     * @return success Whether or not the transfer succeeded\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint256 amount\\r\\n    ) external returns (bool success);\\r\\n\\r\\n    /**\\r\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n     * @dev This will overwrite the approval amount for `spender`\\r\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @param amount The number of tokens that are approved (-1 means infinite)\\r\\n     * @return success Whether or not the approval succeeded\\r\\n     */\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) external returns (bool success);\\r\\n\\r\\n    /**\\r\\n     * @notice Get the current allowance from `owner` for `spender`\\r\\n     * @param owner The address of the account which owns the tokens to be spent\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @return remaining The number of tokens allowed to be spent (-1 means infinite)\\r\\n     */\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256 remaining);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 amount\\r\\n    );\\r\\n}\\r\\n\",\"keccak256\":\"0x0962c83cbc826ed86136fc3c396e4dc069d9dfa4a4228d2b040e87b7e35fffee\",\"license\":\"BSD-3-Clause\"},\"contracts/EIP20NonStandardInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\n/**\\r\\n * @title EIP20NonStandardInterface\\r\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\r\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\r\\n */\\r\\ninterface EIP20NonStandardInterface {\\r\\n    /**\\r\\n     * @notice Get the total number of tokens in circulation\\r\\n     * @return The supply of tokens\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the balance of the specified address\\r\\n     * @param owner The address from which the balance will be retrieved\\r\\n     * @return balance The balance\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    ///\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    ///\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\r\\n     * @param dst The address of the destination account\\r\\n     * @param amount The number of tokens to transfer\\r\\n     */\\r\\n    function transfer(address dst, uint256 amount) external;\\r\\n\\r\\n    ///\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    ///\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\r\\n     * @param src The address of the source account\\r\\n     * @param dst The address of the destination account\\r\\n     * @param amount The number of tokens to transfer\\r\\n     */\\r\\n    function transferFrom(address src, address dst, uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n     * @dev This will overwrite the approval amount for `spender`\\r\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @param amount The number of tokens that are approved\\r\\n     * @return success Whether or not the approval succeeded\\r\\n     */\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) external returns (bool success);\\r\\n\\r\\n    /**\\r\\n     * @notice Get the current allowance from `owner` for `spender`\\r\\n     * @param owner The address of the account which owns the tokens to be spent\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @return remaining The number of tokens allowed to be spent\\r\\n     */\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256 remaining);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 amount\\r\\n    );\\r\\n}\\r\\n\",\"keccak256\":\"0x9482f5bdd98c5e2f0f00af1028223de05a5402fe12b52c036ce5812c87a228b5\",\"license\":\"BSD-3-Clause\"},\"contracts/ErrorReporter.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\ncontract ComptrollerErrorReporter {\\r\\n    enum Error {\\r\\n        NO_ERROR,\\r\\n        UNAUTHORIZED,\\r\\n        COMPTROLLER_MISMATCH,\\r\\n        INSUFFICIENT_SHORTFALL,\\r\\n        INSUFFICIENT_LIQUIDITY,\\r\\n        INVALID_CLOSE_FACTOR,\\r\\n        INVALID_COLLATERAL_FACTOR,\\r\\n        INVALID_LIQUIDATION_INCENTIVE,\\r\\n        MARKET_NOT_ENTERED, // no longer possible\\r\\n        MARKET_NOT_LISTED,\\r\\n        MARKET_ALREADY_LISTED,\\r\\n        MATH_ERROR,\\r\\n        NONZERO_BORROW_BALANCE,\\r\\n        PRICE_ERROR,\\r\\n        REJECTION,\\r\\n        SNAPSHOT_ERROR,\\r\\n        TOO_MANY_ASSETS,\\r\\n        TOO_MUCH_REPAY\\r\\n    }\\r\\n\\r\\n    enum FailureInfo {\\r\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\r\\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\\r\\n        EXIT_MARKET_BALANCE_OWED,\\r\\n        EXIT_MARKET_REJECTION,\\r\\n        SET_CLOSE_FACTOR_OWNER_CHECK,\\r\\n        SET_CLOSE_FACTOR_VALIDATION,\\r\\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\\r\\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\\r\\n        SET_COLLATERAL_FACTOR_VALIDATION,\\r\\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\\r\\n        SET_IMPLEMENTATION_OWNER_CHECK,\\r\\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\\r\\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\\r\\n        SET_MAX_ASSETS_OWNER_CHECK,\\r\\n        SET_PENDING_ADMIN_OWNER_CHECK,\\r\\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\\r\\n        SET_PRICE_ORACLE_OWNER_CHECK,\\r\\n        SUPPORT_MARKET_EXISTS,\\r\\n        SUPPORT_MARKET_OWNER_CHECK,\\r\\n        SET_PAUSE_GUARDIAN_OWNER_CHECK\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\r\\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\r\\n     **/\\r\\n    event Failure(uint error, uint info, uint detail);\\r\\n\\r\\n    /**\\r\\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\r\\n     */\\r\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), 0);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\r\\n     */\\r\\n    function failOpaque(\\r\\n        Error err,\\r\\n        FailureInfo info,\\r\\n        uint opaqueError\\r\\n    ) internal returns (uint) {\\r\\n        emit Failure(uint(err), uint(info), opaqueError);\\r\\n\\r\\n        return uint(err);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract TokenErrorReporter {\\r\\n    uint public constant NO_ERROR = 0; // support legacy return codes\\r\\n\\r\\n    error TransferComptrollerRejection(uint256 errorCode);\\r\\n    error TransferNotAllowed();\\r\\n    error TransferNotEnough();\\r\\n    error TransferTooMuch();\\r\\n\\r\\n    error MintComptrollerRejection(uint256 errorCode);\\r\\n    error MintFreshnessCheck();\\r\\n\\r\\n    error RedeemComptrollerRejection(uint256 errorCode);\\r\\n    error RedeemFreshnessCheck();\\r\\n    error RedeemTransferOutNotPossible();\\r\\n\\r\\n    error BorrowComptrollerRejection(uint256 errorCode);\\r\\n    error BorrowFreshnessCheck();\\r\\n    error BorrowCashNotAvailable();\\r\\n\\r\\n    error RepayBorrowComptrollerRejection(uint256 errorCode);\\r\\n    error RepayBorrowFreshnessCheck();\\r\\n\\r\\n    error LiquidateComptrollerRejection(uint256 errorCode);\\r\\n    error LiquidateFreshnessCheck();\\r\\n    error LiquidateCollateralFreshnessCheck();\\r\\n    error LiquidateAccrueBorrowInterestFailed(uint256 errorCode);\\r\\n    error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);\\r\\n    error LiquidateLiquidatorIsBorrower();\\r\\n    error LiquidateCloseAmountIsZero();\\r\\n    error LiquidateCloseAmountIsUintMax();\\r\\n    error LiquidateRepayBorrowFreshFailed(uint256 errorCode);\\r\\n\\r\\n    error LiquidateSeizeComptrollerRejection(uint256 errorCode);\\r\\n    error LiquidateSeizeLiquidatorIsBorrower();\\r\\n\\r\\n    error AcceptAdminPendingAdminCheck();\\r\\n\\r\\n    error SetComptrollerOwnerCheck();\\r\\n    error SetPendingAdminOwnerCheck();\\r\\n\\r\\n    error SetReserveFactorAdminCheck();\\r\\n    error SetReserveFactorFreshCheck();\\r\\n    error SetReserveFactorBoundsCheck();\\r\\n\\r\\n    error AddReservesFactorFreshCheck(uint256 actualAddAmount);\\r\\n\\r\\n    error SetReserveGuardianOwnerCheck();\\r\\n\\r\\n    error ReduceReservesAdminCheck();\\r\\n    error ReduceReservesFreshCheck();\\r\\n    error ReduceReservesCashNotAvailable();\\r\\n    error ReduceReservesCashValidation();\\r\\n\\r\\n    error SetInterestRateModelOwnerCheck();\\r\\n    error SetInterestRateModelFreshCheck();\\r\\n}\\r\\n\",\"keccak256\":\"0x28e6791db03f8002b4e9c948e4a1600a1d03e1bf243aa8a8bdb04a4cb10eefe0\",\"license\":\"BSD-3-Clause\"},\"contracts/ExponentialNoError.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\n/**\\r\\n * @title Exponential module for storing fixed-precision decimals\\r\\n * @author Compound\\r\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\r\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\r\\n *         `Exp({mantissa: 5100000000000000000})`.\\r\\n */\\r\\ncontract ExponentialNoError {\\r\\n    uint constant expScale = 1e18;\\r\\n    uint constant doubleScale = 1e36;\\r\\n    uint constant halfExpScale = expScale / 2;\\r\\n    uint constant mantissaOne = expScale;\\r\\n\\r\\n    struct Exp {\\r\\n        uint mantissa;\\r\\n    }\\r\\n\\r\\n    struct Double {\\r\\n        uint mantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Truncates the given exp to a whole number value.\\r\\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\r\\n     */\\r\\n    function truncate(Exp memory exp) internal pure returns (uint) {\\r\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\r\\n        return exp.mantissa / expScale;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\r\\n     */\\r\\n    function mul_ScalarTruncate(\\r\\n        Exp memory a,\\r\\n        uint scalar\\r\\n    ) internal pure returns (uint) {\\r\\n        Exp memory product = mul_(a, scalar);\\r\\n        return truncate(product);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\r\\n     */\\r\\n    function mul_ScalarTruncateAddUInt(\\r\\n        Exp memory a,\\r\\n        uint scalar,\\r\\n        uint addend\\r\\n    ) internal pure returns (uint) {\\r\\n        Exp memory product = mul_(a, scalar);\\r\\n        return add_(truncate(product), addend);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if first Exp is less than second Exp.\\r\\n     */\\r\\n    function lessThanExp(\\r\\n        Exp memory left,\\r\\n        Exp memory right\\r\\n    ) internal pure returns (bool) {\\r\\n        return left.mantissa < right.mantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if left Exp <= right Exp.\\r\\n     */\\r\\n    function lessThanOrEqualExp(\\r\\n        Exp memory left,\\r\\n        Exp memory right\\r\\n    ) internal pure returns (bool) {\\r\\n        return left.mantissa <= right.mantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if left Exp > right Exp.\\r\\n     */\\r\\n    function greaterThanExp(\\r\\n        Exp memory left,\\r\\n        Exp memory right\\r\\n    ) internal pure returns (bool) {\\r\\n        return left.mantissa > right.mantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns true if Exp is exactly zero\\r\\n     */\\r\\n    function isZeroExp(Exp memory value) internal pure returns (bool) {\\r\\n        return value.mantissa == 0;\\r\\n    }\\r\\n\\r\\n    function safe224(\\r\\n        uint n,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint224) {\\r\\n        require(n < 2 ** 224, errorMessage);\\r\\n        return uint224(n);\\r\\n    }\\r\\n\\r\\n    function safe32(\\r\\n        uint n,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint32) {\\r\\n        require(n < 2 ** 32, errorMessage);\\r\\n        return uint32(n);\\r\\n    }\\r\\n\\r\\n    function add_(\\r\\n        Exp memory a,\\r\\n        Exp memory b\\r\\n    ) internal pure returns (Exp memory) {\\r\\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function add_(\\r\\n        Double memory a,\\r\\n        Double memory b\\r\\n    ) internal pure returns (Double memory) {\\r\\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function add_(uint a, uint b) internal pure returns (uint) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    function sub_(\\r\\n        Exp memory a,\\r\\n        Exp memory b\\r\\n    ) internal pure returns (Exp memory) {\\r\\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function sub_(\\r\\n        Double memory a,\\r\\n        Double memory b\\r\\n    ) internal pure returns (Double memory) {\\r\\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function sub_(uint a, uint b) internal pure returns (uint) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function mul_(\\r\\n        Exp memory a,\\r\\n        Exp memory b\\r\\n    ) internal pure returns (Exp memory) {\\r\\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\r\\n    }\\r\\n\\r\\n    function mul_(Exp memory a, uint b) internal pure returns (Exp memory) {\\r\\n        return Exp({mantissa: mul_(a.mantissa, b)});\\r\\n    }\\r\\n\\r\\n    function mul_(uint a, Exp memory b) internal pure returns (uint) {\\r\\n        return mul_(a, b.mantissa) / expScale;\\r\\n    }\\r\\n\\r\\n    function mul_(\\r\\n        Double memory a,\\r\\n        Double memory b\\r\\n    ) internal pure returns (Double memory) {\\r\\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\r\\n    }\\r\\n\\r\\n    function mul_(\\r\\n        Double memory a,\\r\\n        uint b\\r\\n    ) internal pure returns (Double memory) {\\r\\n        return Double({mantissa: mul_(a.mantissa, b)});\\r\\n    }\\r\\n\\r\\n    function mul_(uint a, Double memory b) internal pure returns (uint) {\\r\\n        return mul_(a, b.mantissa) / doubleScale;\\r\\n    }\\r\\n\\r\\n    function mul_(uint a, uint b) internal pure returns (uint) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    function div_(\\r\\n        Exp memory a,\\r\\n        Exp memory b\\r\\n    ) internal pure returns (Exp memory) {\\r\\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function div_(Exp memory a, uint b) internal pure returns (Exp memory) {\\r\\n        return Exp({mantissa: div_(a.mantissa, b)});\\r\\n    }\\r\\n\\r\\n    function div_(uint a, Exp memory b) internal pure returns (uint) {\\r\\n        return div_(mul_(a, expScale), b.mantissa);\\r\\n    }\\r\\n\\r\\n    function div_(\\r\\n        Double memory a,\\r\\n        Double memory b\\r\\n    ) internal pure returns (Double memory) {\\r\\n        return\\r\\n            Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\r\\n    }\\r\\n\\r\\n    function div_(\\r\\n        Double memory a,\\r\\n        uint b\\r\\n    ) internal pure returns (Double memory) {\\r\\n        return Double({mantissa: div_(a.mantissa, b)});\\r\\n    }\\r\\n\\r\\n    function div_(uint a, Double memory b) internal pure returns (uint) {\\r\\n        return div_(mul_(a, doubleScale), b.mantissa);\\r\\n    }\\r\\n\\r\\n    function div_(uint a, uint b) internal pure returns (uint) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    function fraction(uint a, uint b) internal pure returns (Double memory) {\\r\\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x01ff129a3a6e3dc1e03b30bb3571458b8cb6c979dd54ce2e8a0c31cc18d6a102\",\"license\":\"BSD-3-Clause\"},\"contracts/InterestRateModel.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\n/**\\r\\n * @title Compound's InterestRateModel Interface\\r\\n * @author Compound\\r\\n */\\r\\nabstract contract InterestRateModel {\\r\\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\\r\\n    bool public constant isInterestRateModel = true;\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the current borrow interest rate per block\\r\\n     * @param cash The total amount of cash the market has\\r\\n     * @param borrows The total amount of borrows the market has outstanding\\r\\n     * @param reserves The total amount of reserves the market has\\r\\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\r\\n     */\\r\\n    function getBorrowRate(\\r\\n        uint cash,\\r\\n        uint borrows,\\r\\n        uint reserves\\r\\n    ) external view virtual returns (uint);\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the current supply interest rate per block\\r\\n     * @param cash The total amount of cash the market has\\r\\n     * @param borrows The total amount of borrows the market has outstanding\\r\\n     * @param reserves The total amount of reserves the market has\\r\\n     * @param reserveFactorMantissa The current reserve factor the market has\\r\\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\\r\\n     */\\r\\n    function getSupplyRate(\\r\\n        uint cash,\\r\\n        uint borrows,\\r\\n        uint reserves,\\r\\n        uint reserveFactorMantissa\\r\\n    ) external view virtual returns (uint);\\r\\n}\\r\\n\",\"keccak256\":\"0xdcebe8eff94635acca1ef41ce1bff4a1dfc83dca53def658fa77cf5e35e29562\",\"license\":\"BSD-3-Clause\"},\"contracts/Lens/BasicLens.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\nimport \\\"../EIP20Interface.sol\\\";\\r\\nimport \\\"../PriceOracle.sol\\\";\\r\\n\\r\\nimport \\\"../RewardDistributor.sol\\\";\\r\\n\\r\\ninterface ComptrollerLensInterface {\\r\\n    function claimComp(address) external;\\r\\n\\r\\n    function rewardDistributor() external view returns (address);\\r\\n}\\r\\n\\r\\ncontract BasicLens {\\r\\n    function rewardsAccrued(\\r\\n        ComptrollerLensInterface comptroller,\\r\\n        address account\\r\\n    )\\r\\n        external\\r\\n        returns (address[] memory rewardTokens, uint256[] memory accrued)\\r\\n    {\\r\\n        address externalRewardDistributor = comptroller.rewardDistributor();\\r\\n\\r\\n        rewardTokens = RewardDistributor(externalRewardDistributor)\\r\\n            .getRewardTokens();\\r\\n\\r\\n        uint256[] memory beforeBalances = getBalancesInternal(\\r\\n            rewardTokens,\\r\\n            account\\r\\n        );\\r\\n\\r\\n        comptroller.claimComp(account);\\r\\n\\r\\n        uint256[] memory afterBalances = getBalancesInternal(\\r\\n            rewardTokens,\\r\\n            account\\r\\n        );\\r\\n\\r\\n        accrued = new uint256[](rewardTokens.length);\\r\\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\\r\\n            accrued[i] = afterBalances[i] - beforeBalances[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getBalancesInternal(\\r\\n        address[] memory tokens,\\r\\n        address account\\r\\n    ) internal view returns (uint256[] memory balances) {\\r\\n        balances = new uint256[](tokens.length);\\r\\n        for (uint256 i = 0; i < tokens.length; i++) {\\r\\n            balances[i] = EIP20Interface(tokens[i]).balanceOf(account);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x759a61aa6d4c8d02b4587ca2d88322f5dc5ccdd25961e90794b71001d50349df\",\"license\":\"BSD-3-Clause\"},\"contracts/PriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\nimport \\\"./CToken.sol\\\";\\r\\n\\r\\nabstract contract PriceOracle {\\r\\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\\r\\n    bool public constant isPriceOracle = true;\\r\\n\\r\\n    /**\\r\\n     * @notice Get the underlying price of a cToken asset\\r\\n     * @param cToken The cToken to get the underlying price of\\r\\n     * @return The underlying asset price mantissa (scaled by 1e18).\\r\\n     *  Zero means the price is unavailable.\\r\\n     */\\r\\n    function getUnderlyingPrice(\\r\\n        CToken cToken\\r\\n    ) external view virtual returns (uint);\\r\\n}\\r\\n\",\"keccak256\":\"0x7b9080593d93f0cbd66f37b4b29b00dfe50cfff772b6cd1bf259c6d71c7b47ce\",\"license\":\"BSD-3-Clause\"},\"contracts/RewardDistributor.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\r\\n\\r\\nimport \\\"./CTokenInterfaces.sol\\\";\\r\\nimport \\\"./EIP20Interface.sol\\\";\\r\\nimport \\\"./ExponentialNoError.sol\\\";\\r\\n\\r\\nstruct RewardMarketState {\\r\\n    /// @notice The supply speed for each market\\r\\n    uint256 supplySpeed;\\r\\n    /// @notice The supply index for each market\\r\\n    uint224 supplyIndex;\\r\\n    /// @notice The last block number that Reward accrued for supply\\r\\n    uint32 supplyBlock;\\r\\n    /// @notice The borrow speed for each market\\r\\n    uint256 borrowSpeed;\\r\\n    /// @notice The borrow index for each market\\r\\n    uint224 borrowIndex;\\r\\n    /// @notice The last block number that Reward accrued for borrow\\r\\n    uint32 borrowBlock;\\r\\n}\\r\\n\\r\\nstruct RewardAccountState {\\r\\n    /// @notice The supply index for each market as of the last time the account accrued Reward\\r\\n    mapping(address => uint256) supplierIndex;\\r\\n    /// @notice The borrow index for each market as of the last time the account accrued Reward\\r\\n    mapping(address => uint256) borrowerIndex;\\r\\n    /// @notice Accrued Reward but not yet transferred\\r\\n    uint256 rewardAccrued;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Reward Distributor (version 1)\\r\\n * @author Sonne Finance\\r\\n * @notice This contract is used to distribute rewards to users for supplying and borrowing assets.\\r\\n * Each supply and borrow changing action from comptroller will trigger index update for each reward token.\\r\\n */\\r\\ncontract RewardDistributor is\\r\\n    Initializable,\\r\\n    OwnableUpgradeable,\\r\\n    ExponentialNoError\\r\\n{\\r\\n    event RewardAccrued(\\r\\n        address indexed rewardToken,\\r\\n        address indexed user,\\r\\n        uint256 deltaAccrued,\\r\\n        uint256 totalAccrued\\r\\n    );\\r\\n\\r\\n    event RewardGranted(\\r\\n        address indexed rewardToken,\\r\\n        address indexed user,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    event SupplySpeedUpdated(\\r\\n        address indexed rewardToken,\\r\\n        address indexed cToken,\\r\\n        uint256 supplySpeed\\r\\n    );\\r\\n\\r\\n    event BorrowSpeedUpdated(\\r\\n        address indexed rewardToken,\\r\\n        address indexed cToken,\\r\\n        uint256 borrowSpeed\\r\\n    );\\r\\n\\r\\n    /// @notice The initial reward index for a market\\r\\n    uint224 public constant rewardInitialIndex = 1e36;\\r\\n\\r\\n    /// @notice The comptroller that rewards are distributed to\\r\\n    address public comptroller;\\r\\n\\r\\n    /// @notice The Reward state for each reward token for each market\\r\\n    mapping(address => mapping(address => RewardMarketState))\\r\\n        public rewardMarketState;\\r\\n\\r\\n    /// @notice The Reward state for each reward token for each account\\r\\n    mapping(address => mapping(address => RewardAccountState))\\r\\n        public rewardAccountState;\\r\\n\\r\\n    /// @notice Added reward tokens\\r\\n    address[] public rewardTokens;\\r\\n    /// @notice Flag to check if reward token added before\\r\\n    mapping(address => bool) public rewardTokenExists;\\r\\n\\r\\n    modifier onlyComptroller() {\\r\\n        require(\\r\\n            msg.sender == comptroller,\\r\\n            \\\"RewardDistributor: only comptroller can call this function\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function initialize(address comptroller_) public initializer {\\r\\n        __Ownable_init();\\r\\n\\r\\n        comptroller = comptroller_;\\r\\n    }\\r\\n\\r\\n    function _whitelistToken(address rewardToken_) public onlyOwner {\\r\\n        require(\\r\\n            rewardToken_ != address(0),\\r\\n            \\\"RewardDistributor: reward token cannot be zero address\\\"\\r\\n        );\\r\\n        require(\\r\\n            !rewardTokenExists[rewardToken_],\\r\\n            \\\"RewardDistributor: reward token already exists\\\"\\r\\n        );\\r\\n\\r\\n        rewardTokens.push(rewardToken_);\\r\\n        rewardTokenExists[rewardToken_] = true;\\r\\n    }\\r\\n\\r\\n    function _updateRewardSpeeds(\\r\\n        address rewardToken_,\\r\\n        address[] memory cTokens,\\r\\n        uint256[] memory supplySpeeds,\\r\\n        uint256[] memory borrowSpeeds\\r\\n    ) public onlyOwner {\\r\\n        require(\\r\\n            rewardTokenExists[rewardToken_],\\r\\n            \\\"RewardDistributor: reward token does not exist\\\"\\r\\n        );\\r\\n        require(\\r\\n            cTokens.length == supplySpeeds.length,\\r\\n            \\\"RewardDistributor: supply speed array length mismatch\\\"\\r\\n        );\\r\\n        require(\\r\\n            cTokens.length == borrowSpeeds.length,\\r\\n            \\\"RewardDistributor: borrow speed array length mismatch\\\"\\r\\n        );\\r\\n\\r\\n        for (uint256 i = 0; i < cTokens.length; i++) {\\r\\n            updateRewardSpeedInternal(\\r\\n                rewardToken_,\\r\\n                cTokens[i],\\r\\n                supplySpeeds[i],\\r\\n                borrowSpeeds[i]\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateRewardSpeedInternal(\\r\\n        address rewardToken,\\r\\n        address cToken,\\r\\n        uint256 supplySpeed,\\r\\n        uint256 borrowSpeed\\r\\n    ) internal {\\r\\n        RewardMarketState storage marketState = rewardMarketState[rewardToken][\\r\\n            cToken\\r\\n        ];\\r\\n\\r\\n        if (marketState.supplySpeed != supplySpeed) {\\r\\n            if (marketState.supplyIndex == 0) {\\r\\n                marketState.supplyIndex = rewardInitialIndex;\\r\\n            }\\r\\n\\r\\n            notifySupplyIndexInternal(rewardToken, cToken);\\r\\n            marketState.supplySpeed = supplySpeed;\\r\\n            emit SupplySpeedUpdated(rewardToken, cToken, supplySpeed);\\r\\n        }\\r\\n\\r\\n        if (marketState.borrowSpeed != borrowSpeed) {\\r\\n            if (marketState.borrowIndex == 0) {\\r\\n                marketState.borrowIndex = rewardInitialIndex;\\r\\n            }\\r\\n\\r\\n            notifyBorrowIndexInternal(rewardToken, cToken);\\r\\n            marketState.borrowSpeed = borrowSpeed;\\r\\n            emit BorrowSpeedUpdated(rewardToken, cToken, borrowSpeed);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifySupplyIndex(address cToken) external onlyComptroller {\\r\\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\\r\\n            notifySupplyIndexInternal(rewardTokens[i], cToken);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifySupplyIndexInternal(\\r\\n        address rewardToken,\\r\\n        address cToken\\r\\n    ) internal {\\r\\n        RewardMarketState storage marketState = rewardMarketState[rewardToken][\\r\\n            cToken\\r\\n        ];\\r\\n\\r\\n        uint32 blockNumber = getBlockNumber();\\r\\n\\r\\n        if (blockNumber > marketState.supplyBlock) {\\r\\n            if (marketState.supplySpeed > 0) {\\r\\n                uint256 deltaBlocks = blockNumber - marketState.supplyBlock;\\r\\n                uint256 supplyTokens = CTokenInterface(cToken).totalSupply();\\r\\n                uint256 accrued = mul_(deltaBlocks, marketState.supplySpeed);\\r\\n                Double memory ratio = supplyTokens > 0\\r\\n                    ? fraction(accrued, supplyTokens)\\r\\n                    : Double({mantissa: 0});\\r\\n                marketState.supplyIndex = safe224(\\r\\n                    add_(Double({mantissa: marketState.supplyIndex}), ratio)\\r\\n                        .mantissa,\\r\\n                    \\\"new index exceeds 224 bits\\\"\\r\\n                );\\r\\n            }\\r\\n\\r\\n            marketState.supplyBlock = blockNumber;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifyBorrowIndex(address cToken) external onlyComptroller {\\r\\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\\r\\n            notifyBorrowIndexInternal(rewardTokens[i], cToken);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifyBorrowIndexInternal(\\r\\n        address rewardToken,\\r\\n        address cToken\\r\\n    ) internal {\\r\\n        Exp memory marketBorrowIndex = Exp({\\r\\n            mantissa: CTokenInterface(cToken).borrowIndex()\\r\\n        });\\r\\n\\r\\n        RewardMarketState storage marketState = rewardMarketState[rewardToken][\\r\\n            cToken\\r\\n        ];\\r\\n\\r\\n        uint32 blockNumber = getBlockNumber();\\r\\n\\r\\n        if (blockNumber > marketState.borrowBlock) {\\r\\n            if (marketState.borrowSpeed > 0) {\\r\\n                uint256 deltaBlocks = blockNumber - marketState.borrowBlock;\\r\\n                uint256 borrowAmount = div_(\\r\\n                    CTokenInterface(cToken).totalBorrows(),\\r\\n                    marketBorrowIndex\\r\\n                );\\r\\n                uint256 accrued = mul_(deltaBlocks, marketState.borrowSpeed);\\r\\n                Double memory ratio = borrowAmount > 0\\r\\n                    ? fraction(accrued, borrowAmount)\\r\\n                    : Double({mantissa: 0});\\r\\n                marketState.borrowIndex = safe224(\\r\\n                    add_(Double({mantissa: marketState.borrowIndex}), ratio)\\r\\n                        .mantissa,\\r\\n                    \\\"new index exceeds 224 bits\\\"\\r\\n                );\\r\\n            }\\r\\n\\r\\n            marketState.borrowBlock = blockNumber;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifySupplier(\\r\\n        address cToken,\\r\\n        address supplier\\r\\n    ) external onlyComptroller {\\r\\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\\r\\n            notifySupplierInternal(rewardTokens[i], cToken, supplier);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifySupplierInternal(\\r\\n        address rewardToken,\\r\\n        address cToken,\\r\\n        address supplier\\r\\n    ) internal {\\r\\n        RewardMarketState storage marketState = rewardMarketState[rewardToken][\\r\\n            cToken\\r\\n        ];\\r\\n        RewardAccountState storage accountState = rewardAccountState[\\r\\n            rewardToken\\r\\n        ][supplier];\\r\\n\\r\\n        uint256 supplyIndex = marketState.supplyIndex;\\r\\n        uint256 supplierIndex = accountState.supplierIndex[cToken];\\r\\n\\r\\n        // Update supplier's index to the current index since we are distributing accrued Reward\\r\\n        accountState.supplierIndex[cToken] = supplyIndex;\\r\\n\\r\\n        if (supplierIndex == 0 && supplyIndex >= rewardInitialIndex) {\\r\\n            supplierIndex = rewardInitialIndex;\\r\\n        }\\r\\n\\r\\n        // Calculate change in the cumulative sum of the Reward per cToken accrued\\r\\n        Double memory deltaIndex = Double({\\r\\n            mantissa: sub_(supplyIndex, supplierIndex)\\r\\n        });\\r\\n\\r\\n        uint256 supplierTokens = CTokenInterface(cToken).balanceOf(supplier);\\r\\n\\r\\n        // Calculate Reward accrued: cTokenAmount * accruedPerCToken\\r\\n        uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\\r\\n\\r\\n        accountState.rewardAccrued = add_(\\r\\n            accountState.rewardAccrued,\\r\\n            supplierDelta\\r\\n        );\\r\\n\\r\\n        emit RewardAccrued(\\r\\n            rewardToken,\\r\\n            supplier,\\r\\n            supplierDelta,\\r\\n            accountState.rewardAccrued\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function notifyBorrower(\\r\\n        address cToken,\\r\\n        address borrower\\r\\n    ) external onlyComptroller {\\r\\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\\r\\n            notifyBorrowerInternal(rewardTokens[i], cToken, borrower);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function notifyBorrowerInternal(\\r\\n        address rewardToken,\\r\\n        address cToken,\\r\\n        address borrower\\r\\n    ) internal {\\r\\n        Exp memory marketBorrowIndex = Exp({\\r\\n            mantissa: CTokenInterface(cToken).borrowIndex()\\r\\n        });\\r\\n\\r\\n        RewardMarketState storage marketState = rewardMarketState[rewardToken][\\r\\n            cToken\\r\\n        ];\\r\\n        RewardAccountState storage accountState = rewardAccountState[\\r\\n            rewardToken\\r\\n        ][borrower];\\r\\n\\r\\n        uint256 borrowIndex = marketState.borrowIndex;\\r\\n        uint256 borrowerIndex = accountState.borrowerIndex[cToken];\\r\\n\\r\\n        // Update borrowers's index to the current index since we are distributing accrued Reward\\r\\n        accountState.borrowerIndex[cToken] = borrowIndex;\\r\\n\\r\\n        if (borrowerIndex == 0 && borrowIndex >= rewardInitialIndex) {\\r\\n            // Covers the case where users borrowed tokens before the market's borrow state index was set.\\r\\n            // Rewards the user with Reward accrued from the start of when borrower rewards were first\\r\\n            // set for the market.\\r\\n            borrowerIndex = rewardInitialIndex;\\r\\n        }\\r\\n\\r\\n        // Calculate change in the cumulative sum of the Reward per borrowed unit accrued\\r\\n        Double memory deltaIndex = Double({\\r\\n            mantissa: sub_(borrowIndex, borrowerIndex)\\r\\n        });\\r\\n\\r\\n        uint256 borrowerAmount = div_(\\r\\n            CTokenInterface(cToken).borrowBalanceStored(borrower),\\r\\n            marketBorrowIndex\\r\\n        );\\r\\n\\r\\n        // Calculate Reward accrued: cTokenAmount * accruedPerBorrowedUnit\\r\\n        uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\\r\\n\\r\\n        accountState.rewardAccrued = add_(\\r\\n            accountState.rewardAccrued,\\r\\n            borrowerDelta\\r\\n        );\\r\\n\\r\\n        emit RewardAccrued(\\r\\n            rewardToken,\\r\\n            borrower,\\r\\n            borrowerDelta,\\r\\n            accountState.rewardAccrued\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function claim(address[] memory holders) public {\\r\\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\\r\\n            claimInternal(rewardTokens[i], holders);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function claimInternal(\\r\\n        address rewardToken,\\r\\n        address[] memory holders\\r\\n    ) internal {\\r\\n        for (uint256 j = 0; j < holders.length; j++) {\\r\\n            RewardAccountState storage accountState = rewardAccountState[\\r\\n                rewardToken\\r\\n            ][holders[j]];\\r\\n\\r\\n            accountState.rewardAccrued = grantRewardInternal(\\r\\n                rewardToken,\\r\\n                holders[j],\\r\\n                accountState.rewardAccrued\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getBlockNumber() public view returns (uint32) {\\r\\n        return safe32(block.timestamp, \\\"block number exceeds 32 bits\\\");\\r\\n    }\\r\\n\\r\\n    function _grantReward(\\r\\n        address token,\\r\\n        address user,\\r\\n        uint256 amount\\r\\n    ) public onlyOwner {\\r\\n        require(\\r\\n            rewardTokenExists[token],\\r\\n            \\\"RewardDistributor: grant reward token does not exist\\\"\\r\\n        );\\r\\n        grantRewardInternal(token, user, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer Reward to the user\\r\\n     * @dev Note: If there is not enough Reward, we do not perform the transfer all.\\r\\n     * @param user The address of the user to transfer Reward to\\r\\n     * @param amount The amount of Reward to (possibly) transfer\\r\\n     * @return The amount of Reward which was NOT transferred to the user\\r\\n     */\\r\\n    function grantRewardInternal(\\r\\n        address token,\\r\\n        address user,\\r\\n        uint256 amount\\r\\n    ) internal returns (uint256) {\\r\\n        uint256 remaining = EIP20Interface(token).balanceOf(address(this));\\r\\n        if (amount > 0 && amount <= remaining) {\\r\\n            EIP20Interface(token).transfer(user, amount);\\r\\n\\r\\n            emit RewardGranted(token, user, amount);\\r\\n\\r\\n            return 0;\\r\\n        }\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    /** Getters */\\r\\n    function getRewardTokens() public view returns (address[] memory) {\\r\\n        return rewardTokens;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x85169655a294d93089d7a7b6a0a375ef7647ca57b3d2fa26534eab1f6b6c37a7\",\"license\":\"BSD-3-Clause\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610611806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063cf168a9d14610030575b600080fd5b61004361003e366004610398565b61005a565b6040516100519291906103d1565b60405180910390f35b6060806000846001600160a01b031663acc2166a6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561009d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100c19190610465565b9050806001600160a01b031663c4f59f9b6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610101573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610129919081019061049f565b92506000610137848661026e565b6040516374d7814960e11b81526001600160a01b0387811660048301529192509087169063e9af029290602401600060405180830381600087803b15801561017e57600080fd5b505af1158015610192573d6000803e3d6000fd5b5050505060006101a2858761026e565b9050845167ffffffffffffffff8111156101be576101be610489565b6040519080825280602002602001820160405280156101e7578160200160208202803683370190505b50935060005b85518110156102635782818151811061020857610208610564565b602002602001015182828151811061022257610222610564565b60200260200101516102349190610590565b85828151811061024657610246610564565b60209081029190910101528061025b816105a7565b9150506101ed565b505050509250929050565b6060825167ffffffffffffffff81111561028a5761028a610489565b6040519080825280602002602001820160405280156102b3578160200160208202803683370190505b50905060005b8351811015610379578381815181106102d4576102d4610564565b60209081029190910101516040516370a0823160e01b81526001600160a01b038581166004830152909116906370a0823190602401602060405180830381865afa158015610326573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061034a91906105c2565b82828151811061035c5761035c610564565b602090810291909101015280610371816105a7565b9150506102b9565b5092915050565b6001600160a01b038116811461039557600080fd5b50565b600080604083850312156103ab57600080fd5b82356103b681610380565b915060208301356103c681610380565b809150509250929050565b604080825283519082018190526000906020906060840190828701845b828110156104135781516001600160a01b0316845292840192908401906001016103ee565b5050508381038285015284518082528583019183019060005b818110156104485783518352928401929184019160010161042c565b5090979650505050505050565b805161046081610380565b919050565b60006020828403121561047757600080fd5b815161048281610380565b9392505050565b634e487b7160e01b600052604160045260246000fd5b600060208083850312156104b257600080fd5b825167ffffffffffffffff808211156104ca57600080fd5b818501915085601f8301126104de57600080fd5b8151818111156104f0576104f0610489565b8060051b604051601f19603f8301168101818110858211171561051557610515610489565b60405291825284820192508381018501918883111561053357600080fd5b938501935b828510156105585761054985610455565b84529385019392850192610538565b98975050505050505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000828210156105a2576105a261057a565b500390565b60006000198214156105bb576105bb61057a565b5060010190565b6000602082840312156105d457600080fd5b505191905056fea264697066735822122098a4babc560058457091e0eed8f6fdc342749be4a476094f9d665131a60bdfa764736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063cf168a9d14610030575b600080fd5b61004361003e366004610398565b61005a565b6040516100519291906103d1565b60405180910390f35b6060806000846001600160a01b031663acc2166a6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561009d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100c19190610465565b9050806001600160a01b031663c4f59f9b6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610101573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610129919081019061049f565b92506000610137848661026e565b6040516374d7814960e11b81526001600160a01b0387811660048301529192509087169063e9af029290602401600060405180830381600087803b15801561017e57600080fd5b505af1158015610192573d6000803e3d6000fd5b5050505060006101a2858761026e565b9050845167ffffffffffffffff8111156101be576101be610489565b6040519080825280602002602001820160405280156101e7578160200160208202803683370190505b50935060005b85518110156102635782818151811061020857610208610564565b602002602001015182828151811061022257610222610564565b60200260200101516102349190610590565b85828151811061024657610246610564565b60209081029190910101528061025b816105a7565b9150506101ed565b505050509250929050565b6060825167ffffffffffffffff81111561028a5761028a610489565b6040519080825280602002602001820160405280156102b3578160200160208202803683370190505b50905060005b8351811015610379578381815181106102d4576102d4610564565b60209081029190910101516040516370a0823160e01b81526001600160a01b038581166004830152909116906370a0823190602401602060405180830381865afa158015610326573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061034a91906105c2565b82828151811061035c5761035c610564565b602090810291909101015280610371816105a7565b9150506102b9565b5092915050565b6001600160a01b038116811461039557600080fd5b50565b600080604083850312156103ab57600080fd5b82356103b681610380565b915060208301356103c681610380565b809150509250929050565b604080825283519082018190526000906020906060840190828701845b828110156104135781516001600160a01b0316845292840192908401906001016103ee565b5050508381038285015284518082528583019183019060005b818110156104485783518352928401929184019160010161042c565b5090979650505050505050565b805161046081610380565b919050565b60006020828403121561047757600080fd5b815161048281610380565b9392505050565b634e487b7160e01b600052604160045260246000fd5b600060208083850312156104b257600080fd5b825167ffffffffffffffff808211156104ca57600080fd5b818501915085601f8301126104de57600080fd5b8151818111156104f0576104f0610489565b8060051b604051601f19603f8301168101818110858211171561051557610515610489565b60405291825284820192508381018501918883111561053357600080fd5b938501935b828510156105585761054985610455565b84529385019392850192610538565b98975050505050505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000828210156105a2576105a261057a565b500390565b60006000198214156105bb576105bb61057a565b5060010190565b6000602082840312156105d457600080fd5b505191905056fea264697066735822122098a4babc560058457091e0eed8f6fdc342749be4a476094f9d665131a60bdfa764736f6c634300080a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}